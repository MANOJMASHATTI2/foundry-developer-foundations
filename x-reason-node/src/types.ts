import { ComputeModule } from '@palantir/compute-module';
import type { Client } from "@osdk/client";

export const TYPES = {
    FoundryClient: Symbol.for("FoundryClient"),
    WeatherService: Symbol.for("WeatherService"),
    WorldDao: Symbol.for("WorldDao"),
    UserDao: Symbol.for("UserDao"),
    MachineDao: Symbol.for("MachineDao"),
    CommsDao: Symbol.for("CommsDao"),
    ThreadsDao: Symbol.for("ThreadsDao"),
    RfpRequestsDao: Symbol.for("RfpRequestsDao"),
    GeminiService: Symbol.for("GeminiService"),
    GeminiSearchStockMarket: Symbol.for("GeminiSearchStockMarket"),
};

export interface GeminiParameters {
    "stopSequences"?: Array<string>;
    "temperature"?: number;
    "maxTokens"?: number;
    "topP"?: number;
    "extractJsonString"?: boolean;
};

export interface GeminiService {
    (user: string, system: string, params?: GeminiParameters): Promise<string>;
}

export interface Token {
    readonly access_token: string;
    readonly expires_in: number;
    readonly refresh_token?: string;
    readonly expires_at: number;
}

export interface BaseOauthClient {
    (): Promise<string>;
    getTokenOrUndefined: () => string | undefined;
    signIn: () => Promise<Token>;
    signOut: () => Promise<void>;
}

export interface FoundryClient {
    client: Client;
    auth: BaseOauthClient;
    ontologyRid: string;
    url: string;
    getUser: () => Promise<User>;
}

// Basic example of calling other services besides Foundry.
export interface WeatherService {
    (city: string): Promise<string>;
}

export interface GeminiSearchStockMarket {
    (userQuery: string): Promise<string>;
}

export interface APIError extends Error {
    response?: {
        data: any;
    };
}

export interface ModuleConfig {
    isTest?: boolean;
}

export interface TestModule {
    listeners: Record<string, any>;
    on(event: string, handler: Function): TestModule;
    register(operation: string, handler: Function): TestModule;
}

export type ComputeModuleType = TestModule | ComputeModule<any>;

export interface GreetingInput {
    message: string;
    userId: string;
}

export interface GreetingResult {
    id: string;
    greeting: string;
}

export interface User {
    id: string;
    username: string;
    givenName?: string;
    familyName?: string;
    email?: string;
    organization?: string;
    attributes: Record<string, any>;
}

export interface MachineExecutions {
    /** Current State */
    /** holds the current state of the state machine */
    currentState: string | undefined;
    /** Id */
    /** The uuid of the machine execution. It uniquely identifies the machine. */
    readonly id: string;
    /** Logs */
    /** Holds the execution logs from a machine execution. The logs are generated by the TypeScript functions */
    logs: string | undefined;
    /** Machine */
    /** Holds the state machine generated for the solution. The machine is a JSON string using the x-reason JSON schema. */
    machine: string | undefined;
    /** State */
    /** The current state of the state machine execution */
    state: string | undefined;
}

export interface Communications {
    /** Channel */
    channel: string | undefined;
    /** Completion Error Task List */
    completionErrorTaskList: string | undefined;
    /** Created On */
    createdOn: number | undefined;
    /** Formatted Message */
    formattedMessage: string | undefined;
    /** Id */
    readonly id: string;
    /** Machine */
    /** Holds the generated state machine for the given task list */
    machine: string | undefined;
    /** Owner */
    owner: string | undefined;
    /** Question Prompt */
    questionPrompt: string | undefined;
    /** Status */
    /** The current status of the tasks to perform. Must be one of Open, Accepted, or Rejected */
    status: string | undefined;
    /** Task List */
    taskList: string | undefined;
    /** Tokens */
    tokens: number | undefined;
    /** type */
    type: string | undefined;
}

export interface Threads {
    /** appId */
    appId: string | undefined;
    /** id */
    readonly id: string;
    /** messages */
    messages: string | undefined;
    /** userId */
    userId: string | undefined;
}

/** Holds notional rfp responses */
export interface RfpRequests {
    /** Created On */
    createdOn: number;
    /** id */
    readonly id: string;
    /** machineExecutionId */
    machineExecutionId: string | undefined;
    /** rfp */
    rfp: string | undefined;
    /** rfpResponse */
    rfpResponse: string | undefined;
    /** vendorId */
    vendorId: string | undefined;
}

export type WorldDao = (input: GreetingInput) => Promise<GreetingResult>;
export type UserDao = () => Promise<User>;
export type MachineDao = {
    upsert: (id: string, stateMachine: string, state: string, logs: string) => Promise<MachineExecutions>,
    delete: (machineExecutionId: string) => Promise<void>,
    read: (machineExecutionId: string) => Promise<MachineExecutions>,
};
export type CommsDao = {
    upsert: (
        channel: string,
        formattedMessage: string,
        status: string,
        taskList: string,
        comType: string,
        owner: string,
        questionPrompt?: string,
        tokens?: number,
        id?: string,) => Promise<Communications>,
    delete: (id: string) => Promise<void>,
    read: (id: string) => Promise<Communications>,
};
export type ThreadsDao = {
    upsert: (messages: string, appId: string, id?: string) => Promise<Threads>,
    delete: (id: string) => Promise<void>,
    read: (id: string) => Promise<Threads>,
};
//RfpRequestsDao
export type RfpRequestsDao = {
    upsert: (
        rfp: string,
        rfpVendorResponse: string,
        vendorId: string,
        machineExecutionId: string,
        id?: string,
    ) => Promise<RfpRequests>,
    delete: (id: string) => Promise<void>,
    read: (id: string) => Promise<RfpRequests>,
    search: (machineExecutionId: string, vendorId: string,) => Promise<RfpRequests>,
};